from . GenomeTrack import GenomeTrack
import numpy as np
import matplotlib.cm as cm
import gzip
from .. utilities import InputError

DEFAULT_COLORMAP = 'viridis'


class EnrichmentHeatmapTrack(GenomeTrack):
    SUPPORTED_ENDINGS = ['.tsv', '.tsv.gz', '.txt']
    TRACK_TYPE = 'enrichment_heatmap'
    OPTIONS_TXT = GenomeTrack.OPTIONS_TXT + f"""
# TSV generated by prepare_enrichment_heatmap.py
file = enrichment_heatmap.tsv
file_type = {TRACK_TYPE}
# colormap to use for the heatmap
colormap = {DEFAULT_COLORMAP}
# if min/max are not set, they are inferred from the matrix
#min_value = auto
#max_value = auto
# sort rows when plotting. Options: input, mean_desc, mean_asc, max_desc, max_asc, metadata:<column>
sort_by = mean_desc
# show sample labels on the y axis (turn off for thousands of rows)
labels = true
# if labels are shown, optionally override their fontsize
#label_fontsize = 6
# rasterize image to keep PDF/SVG small
rasterize = true
# convert NaNs to zero before plotting
nans_to_zeros = false
# show a colorbar next to the heatmap
show_colorbar = true
    """

    DEFAULTS_PROPERTIES = {'min_value': None,
                           'max_value': None,
                           'colormap': DEFAULT_COLORMAP,
                           'sort_by': 'mean_desc',
                           'labels': True,
                           'label_fontsize': None,
                           'rasterize': True,
                           'nans_to_zeros': False,
                           'show_colorbar': True,
                           'orientation': None}
    NECESSARY_PROPERTIES = ['file']
    SYNONYMOUS_PROPERTIES = {'max_value': {'auto': None},
                             'min_value': {'auto': None}}
    POSSIBLE_PROPERTIES = {'sort_by': ['input', 'mean_desc', 'mean_asc',
                                       'max_desc', 'max_asc'],
                           'orientation': [None, 'inverted']}
    BOOLEAN_PROPERTIES = ['labels', 'rasterize', 'nans_to_zeros',
                          'show_colorbar']
    STRING_PROPERTIES = ['file', 'file_type', 'overlay_previous',
                         'title', 'colormap', 'sort_by', 'orientation']
    FLOAT_PROPERTIES = {'max_value': [- np.inf, np.inf],
                        'min_value': [- np.inf, np.inf],
                        'label_fontsize': [0, np.inf],
                        'height': [0, np.inf]}
    INTEGER_PROPERTIES = {}

    def __init__(self, properties_dict):
        GenomeTrack.__init__(self, properties_dict)
        self.bin_edges = None
        self.sample_labels = []
        self.metadata_fields = []
        self.metadata_rows = []
        self.matrix = None
        self.chrom_from_file = None
        self._load_matrix()

    def set_properties_defaults(self):
        if ('sort_by' in self.properties
                and isinstance(self.properties['sort_by'], str)
                and self.properties['sort_by'].startswith('metadata:')
                and self.properties['sort_by'] not in self.POSSIBLE_PROPERTIES['sort_by']):
            # allow arbitrary metadata sort key
            self.POSSIBLE_PROPERTIES['sort_by'] = self.POSSIBLE_PROPERTIES['sort_by'] + [self.properties['sort_by']]
        GenomeTrack.set_properties_defaults(self)
        self.process_color('colormap', colormap_possible=True,
                           colormap_only=True, default_value_is_colormap=True)
        self.cmap = cm.get_cmap(self.properties['colormap'])

    @staticmethod
    def _open_file(path):
        if path.endswith(".gz"):
            return gzip.open(path, "rt")
        return open(path, "r")

    def _load_matrix(self):
        path = self.properties['file']
        if not path:
            raise InputError(f"Section {self.properties['section_name']} needs a TSV file.")
        comments = {}
        header = None
        rows = []
        with self._open_file(path) as handle:
            for line in handle:
                if not line.strip():
                    continue
                if line.startswith("#"):
                    key_val = line[1:].strip().split("\t", 1)
                    if len(key_val) == 2:
                        comments[key_val[0]] = key_val[1]
                    continue
                if header is None:
                    header = line.rstrip("\n").split("\t")
                    continue
                values = line.rstrip("\n").split("\t")
                if len(values) < len(header):
                    values.extend([""] * (len(header) - len(values)))
                rows.append(values)

        if header is None:
            raise InputError(f"The file {path} does not contain a header line.")
        if 'sample' not in header:
            raise InputError(f"The file {path} must contain a 'sample' column.")
        sample_idx = header.index('sample')
        bin_columns = [idx for idx, col in enumerate(header) if col.startswith("bin_")]
        if len(bin_columns) == 0:
            raise InputError(f"The file {path} must contain columns starting with 'bin_'.")
        first_bin_idx = min(bin_columns)
        self.metadata_fields = [col for idx, col in enumerate(header)
                                if idx != sample_idx and idx < first_bin_idx]
        metadata_indexes = [header.index(field) for field in self.metadata_fields]

        matrix_rows = []
        self.sample_labels = []
        self.metadata_rows = []
        for values in rows:
            self.sample_labels.append(values[sample_idx])
            self.metadata_rows.append({field: values[idx] for field, idx in zip(self.metadata_fields, metadata_indexes)})
            try:
                numeric_vals = [float(values[idx]) if values[idx] not in ["", "nan", "NA"] else np.nan
                                for idx in bin_columns]
            except ValueError as e:
                raise InputError(f"Non-numeric value found in bins for section {self.properties['section_name']}: {e}")
            matrix_rows.append(numeric_vals)

        self.matrix = np.array(matrix_rows, dtype=float)
        if self.properties['nans_to_zeros'] and np.any(np.isnan(self.matrix)):
            self.matrix = np.nan_to_num(self.matrix, nan=0.0)

        self.matrix, self.sample_labels, self.metadata_rows = \
            self._sort_rows(self.matrix, self.sample_labels, self.metadata_rows)

        # bin edges and chrom info (if provided)
        if 'bin_edges' in comments:
            try:
                edges = [int(x) for x in comments['bin_edges'].split(",") if x != ""]
            except ValueError:
                self.log.warning(f"Could not parse bin_edges from {path}, will use evenly spaced bins.")
            else:
                if len(edges) == self.matrix.shape[1] + 1:
                    self.bin_edges = np.array(edges)
                else:
                    self.log.warning("bin_edges length does not match number of columns, will use evenly spaced bins.")
        start_val = comments.get('start')
        end_val = comments.get('end')
        chrom_val = comments.get('chrom')
        self.chrom_from_file = chrom_val
        if self.bin_edges is None and start_val and end_val:
            try:
                start_i, end_i = int(start_val), int(end_val)
                self.bin_edges = np.linspace(start_i, end_i, num=self.matrix.shape[1] + 1)
            except ValueError:
                self.log.warning(f"Could not parse start/end from {path}, using index space instead.")

        if self.bin_edges is None:
            self.bin_edges = np.arange(0, self.matrix.shape[1] + 1)

    def _sort_rows(self, matrix, labels, metadata_rows):
        sort_by = self.properties['sort_by']
        reverse = sort_by.endswith('desc')
        if sort_by == 'input':
            return matrix, labels, metadata_rows

        order = list(range(matrix.shape[0]))
        if sort_by.startswith('metadata:'):
            field = sort_by.split("metadata:", 1)[1]
            order = sorted(order, key=lambda i: metadata_rows[i].get(field, ""), reverse=reverse)
        elif sort_by.startswith('mean'):
            mean_vals = np.nanmean(matrix, axis=1)
            order = sorted(order, key=lambda i: mean_vals[i], reverse=reverse)
        elif sort_by.startswith('max'):
            max_vals = np.nanmax(matrix, axis=1)
            order = sorted(order, key=lambda i: max_vals[i], reverse=reverse)

        matrix = matrix[order, :]
        labels = [labels[i] for i in order]
        metadata_rows = [metadata_rows[i] for i in order]
        return matrix, labels, metadata_rows

    def plot(self, ax, chrom_region, start_region, end_region):
        if self.matrix is None or self.matrix.size == 0:
            self.log.warning(f"No data to plot for section {self.properties['section_name']}")
            return
        if self.chrom_from_file and self.chrom_from_file != chrom_region:
            self.log.warning(f"Track {self.properties['section_name']} matrix was generated for {self.chrom_from_file}, "
                             f"but plotting {chrom_region}.")

        data = self.matrix
        labels = self.sample_labels
        if self.properties['orientation'] == 'inverted':
            data = np.flipud(data)
            labels = list(reversed(labels))

        x_edges = self.bin_edges
        if x_edges is None or len(x_edges) != data.shape[1] + 1:
            x_edges = np.linspace(start_region, end_region, num=data.shape[1] + 1)

        y_edges = np.arange(0, data.shape[0] + 1)
        self.last_img_plotted = ax.pcolormesh(x_edges, y_edges, data,
                                              cmap=self.cmap,
                                              vmin=self.properties['min_value'],
                                              vmax=self.properties['max_value'],
                                              shading='auto')
        if self.properties['rasterize']:
            self.last_img_plotted.set_rasterized(True)
        ax.set_xlim(x_edges[0], x_edges[-1])
        ax.set_ylim(0, data.shape[0])
        if self.properties['labels'] and data.shape[0] <= 200:
            ax.set_yticks(np.arange(0.5, data.shape[0] + 0.5))
            fontsize = self.properties['label_fontsize']
            fontsize = fontsize if fontsize is not None else 'small'
            ax.set_yticklabels(labels, fontsize=fontsize)
        else:
            ax.set_yticks([])
        ax.set_xticks([])

    def plot_y_axis(self, ax, plot_axis):
        if self.properties['show_colorbar']:
            GenomeTrack.plot_custom_cobar(self, ax)
